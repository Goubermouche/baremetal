#pragma once
#include "assembler/block.h"

namespace baremetal {
	struct assembler {
		assembler();

// suppress the C4002 "too many arguments for function-like macro invocation 'INST_0'" warning
#pragma warning(push)
#pragma warning(disable : 4002)
// TODO: remove this 
#pragma warning(push)
#pragma warning(disable : 4100)

// function generators
#define INST_0(index, name)                                        \
inline void name() {                                               \
  emit_instruction(index, operand(), operand(), operand());        \
}

#define INST_1(index, name, op_1)                                  \
inline void name(op_1 operand_1) {                                 \
  emit_instruction(index, operand_1, operand(), operand());        \
}

#define INST_2(index, name, op_1, op_2)                            \
inline void name(op_1 operand_1, op_2 operand_2) {                 \
  emit_instruction(index, operand_1, operand_2, operand());        \
}

#define INST_3(index, name, op_1, op_2, op_3)                      \
inline void name(op_1 operand_1, op_2 operand_2, op_3 operand_3) { \
  emit_instruction(index, operand_1, operand_2, operand_3);        \
}

// select which INST_X to call based off of the variable argument count (0-3)
#define INST_SELECT(count) CONCATENATE(INST_, count)
#define INST_HELPER(count, name, ...) EXPAND(INST_SELECT(count)(name, __VA_ARGS__))

/**
 * \brief Creates a method with the appropriate signature for the provided arguments. This
 * function serves as the main construction API for users trying to construct a module in
 * memory using C++ or other bindings. Its also a nice way of having type checking for
 * every instruction without having to type everything ourselves.
 * \param name Symbol name of the given instruction
 * \param opcode Opcode of the given instruction 
 * \param extension Extension of the given instruction
 * \param operands Up to three operands for the given function
 */
#define INST(index, name, opcode, extension, ...) INST_HELPER(GET_ARG_COUNT(__VA_ARGS__), index, name, __VA_ARGS__)

// generate instruction factory methods
#include "assembler/instruction_database.inc"
#pragma warning(pop)
#pragma warning(pop)

// we won't be needing these generators anymore
#undef INST_0
#undef INST_1
#undef INST_2
#undef INST_3

#undef INST_SELECT
#undef INST_HELPER

#undef INST
		[[nodiscard]] auto get_bytes() const -> const utility::dynamic_array<utility::byte>&;
	private:
		static auto find_rex_pair(const operand* operands) -> std::pair<u8, u8>;

		/**
		 * \brief Emits bytes which represent the instruction from our instruction db located at
		 * the specified \b index, with the provided operands. Operands and their types are assumed
		 * to be correct, as the only way to call this function legally is by using the methods
		 * generated by our .inc file.
		 * \param index Index of the instruction in instruction_db
		 * \param op_1 First operand
		 * \param op_2 Second operand
		 * \param op_3 Third operand
		 */
		void emit_instruction(u32 index, operand op_1, operand op_2, operand op_3);

		enum mod_mode {
			INDIRECT,
			INDIRECT_DISP8,
			INDIRECT_DISP32,
			DIRECT
		};

		/**
		 * \brief Computes the REX opcode byte.
		 * \param w REX.W bit (64 bit mode)
		 * \param rx Register register extension
		 * \param base Base register extension
		 * \param index Index register extension
		 * \return Computed REX opcode byte.
		 */
		static auto rex(bool w, u8 rx, u8 base, u8 index) -> u8;

		/**
		 * \brief Computes the mod R/M byte
		 * \param mod Addressing mode (INDIRECT, INDIRECT_DISP8, INDIRECT_DISP32, DIRECT)
		 * \param rx Opcode or register extension
		 * \param rm Register operand / displacement
		 * \return Computed mod R/M byte
		 */
		static auto mod_rx_rm(u8 mod, u8 rx, u8 rm) -> u8;

		static auto direct(u8 rx, u8 reg) -> u8;
	private:
		utility::dynamic_array<utility::byte> m_bytes;
	};
} // namespace baremetal
