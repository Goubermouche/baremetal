// core backend structure, represents the program as a series of sections and basic blocks, constructed in 
// lib/assembler/frontend.cpp. the general hierarchy of a program can be described as follows: 
//
// module 
// - sections
//   - basic blocks
//     - instructions / labels / data
//
// - sections split up individual assembly sections, each sections has a number of symbols, we can't optimize
//   symbolic references across sections.
// - each section contains a list of basic blocks, which represent the program at that point, in order, each 
//   basic block can contain one of the following: 
//   - contiguous list of instructions (list of instructions with none of the following in between them) 
//   - contiguous block of generic data (ie. generated by the db directive)
//   - label

#pragma once
#include "assembler/context.h"
#include "assembler/backend.h"

#include <utility/result.h>

namespace baremetal::assembler {
	using namespace utility::types;

	struct instruction_data {
		operand operands[4]; // instruction operands
		u32 index;           // index in INSTRUCTION_DB
		u8 size;             // size of the encoded instruction in B
	};

	enum basic_block_type : u8 {
		BB_INSTRUCTION, // block containing at least one instruction
		BB_BRANCH,      // subset of BB_INSTRUCTION, ends with branch/jump instruction
		BB_LABEL,       // basic label block, contains no instructions
		BB_DATA         // block containing arbitrary binary data
	};

	struct basic_block {
		struct instruction_block {
			instruction_data** data; // instructions 
			u64 size;                // number of instructions
		};

		struct label_block {
			utility::string_view* name;
		};

		struct data_block {
			u8* data; 
		};

		auto is_instruction_block() const -> bool;
		auto is_data_block() const -> bool;

		basic_block_type type;

		u64 section_index;  // index of the parent section
		u64 start_position; // start position of this block in bytes
		u64 size;           // block size in bytes 

		u64 incoming_control_edge_count = 0; // populated by the cfg analysis pass

		union {
			instruction_block instructions;
			label_block label;
			data_block data;
		};
  };

	enum symbol_type : u8 {
		SYM_REGULAR, 
		SYM_GLOBAL
	};

	struct section {
		struct symbol {
			u64 position;    // offset within the local section
			u64 block_index; // global block index (across all sections)
			symbol_type type = SYM_REGULAR;
		};

		utility::string_view* name;

		u64 position = 0;  // aligned section position
		u64 offset = 0;    // current offset of the section, only used when a section is being constructed
		u64 size = 0;      // unaligned size of this section, in bytes

		utility::map<utility::string_view*, symbol> symbols;
		utility::dynamic_array<basic_block*> blocks;

		// only relevant when constructing the module
		u64 current_block_position = 0;
		u64 current_block_size = 0;
	};

	struct module {
		module();
		module(context* ctx);

		// module construction
		void stage_instruction(const operand* operands, u32 index, u8 size);
		
		void commit_instruction_block(basic_block_type ty);
		void commit_label_block(utility::string_view* name);
		void commit_data_block(const utility::dynamic_array<u8>& data);
		
		[[nodiscard]] auto declare_symbol(utility::string_view* name, symbol_type type = SYM_REGULAR) -> utility::result<void>;
		// TODO: predeclare_symbol for global symbols

		void set_section(utility::string_view* name);

		// misc
		[[nodiscard]] auto get_global_symbol_position(utility::string_view* name) const -> u64;
		[[nodiscard]] auto get_symbol(utility::string_view* name) const -> section::symbol;
		[[nodiscard]] auto get_block_at_index(u64 i) const -> basic_block*;
		[[nodiscard]] auto get_block_count() const -> u64;

		void recalculate_block_sizes();
		void print_section_info();

		[[nodiscard]] auto resolve_instruction(const instruction_data* data, const section& section, u64 position) const -> backend::code;
	private:
		void add_block(basic_block* block);
	public:
		utility::dynamic_array<section> sections; // all sections, in order of declaration ([0] = '.text') 
		context* ctx;
	private:
		u64 m_section_index = 0; // index of the current section, used when constructing the module
		u64 m_block_count = 0;   // total block count, across all sections

		// when creating the module instructions are added (staged) one by one (stage_instruction), once we're done
		// with these instructions we submit (commit) the staged block and that way we finalize it
		// staged -> commited -> finalized
		utility::dynamic_array<instruction_data*> m_staged_block;
	};
} // namespace baremetal::assembler
